<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subscription Detector</title>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Recursive:slnt,wght,CASL,CRSV,MONO@-15,415,1,1,1&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/roughjs@4.4.1/bundled/rough.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vivus@0.4.6/dist/vivus.min.js"></script>

</head>
<body>
    <div class="container sketchy-border">
        <canvas id="sketch" width="400" height="200"></canvas>

   <!-- Your SVG -->
    <svg id="headline-svg" width="683" height="181" viewBox="0 0 683 181" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M1.6778 179.298C14.9456 160.723 34.7739 148.499 48.2589 129.737C60.5456 112.642 74.9105 94.9552 84.4642 76.2017C87.6196 70.0077 91.4365 64.5177 95.0609 58.7613C97.0564 55.5919 96.9173 50.6533 100.028 48.1647C103.5 45.3873 102.555 36.3137 105.437 32.7112C111.397 25.2604 111.536 14.3156 110.956 4.45347C110.8 1.80748 106.853 1.92466 104.995 2.90812C100.864 5.09516 100.98 14.4445 100.028 18.2512C96.4905 32.4014 101.539 50.6753 104.995 64.5012C112.238 93.4704 113.667 142.892 77.179 153.027C48.2861 161.053 37.4415 130.841 37.4415 107.771C37.4415 105.993 36.7934 91.0657 41.4153 96.8431C47.911 104.963 66.5137 104.119 75.1921 108.212C89.8528 115.128 105.368 117.705 121.773 117.705C130.027 117.705 134.503 107.771 141.752 107.771C151.164 107.771 164.346 93.2677 166.699 85.0322C167.313 82.8823 172.16 75.3225 172.549 81.9415C173.102 91.3362 170.399 100.748 168.575 109.868C166.54 120.046 160.428 133.401 169.017 141.989C182.944 155.917 190.057 140.689 195.067 124.99C199.723 110.402 201.535 95.0757 205.884 80.3962C208.145 72.7651 207.627 81.4161 213.28 83.9284C238.517 95.1448 253.955 66.1032 258.757 45.2948C259.933 40.2003 259.349 12.5516 255.556 29.6205C249.813 55.4633 247.985 81.6506 243.193 107.661C241.957 114.374 234.006 143.104 246.505 143.535C265.646 144.195 273.056 113.234 271.782 97.9469C271.188 90.8133 261.958 71.6926 261.958 78.8508C261.958 91.2098 288.075 82.1402 292.203 79.5131C301.989 73.2859 305.954 62.5361 309.202 51.9177C309.566 50.7259 313.396 36.7216 313.396 39.4445C313.396 57.7173 305.959 76.024 305.669 94.5251C305.435 109.55 302.8 154.561 303.683 139.561C303.881 136.182 314.299 127.579 316.597 124.77C322.261 117.847 323.481 108.2 329.07 101.369C331.229 98.73 334.482 91.8646 335.362 88.7852C338.36 78.2929 347.212 71.4797 356.445 67.5919C375.889 59.4048 345.168 130.797 355.783 131.613C364.363 132.273 367.035 128.274 371.016 120.796C378.98 105.832 383.986 88.5245 393.092 74.2148C395.186 70.924 397.933 67.068 402.033 66.1569C406.433 65.1792 407.761 60.561 403.689 63.8389C394.4 71.3153 389.26 83.3187 387.131 94.7458C386.747 96.8088 382.367 113.28 386.248 115.498C392.302 118.957 412.593 72.7226 415.389 65.605C416.399 63.0348 418.593 61.5175 420.467 59.6444C421.842 58.2685 412.62 77.8388 411.084 81.8312C408.684 88.0722 390.862 131.613 407.993 131.613C445.803 131.613 443.652 86.323 467.6 66.1569C475.859 59.202 467.23 66.2717 464.73 71.8968C460.655 81.0648 453.619 88.5854 450.711 98.2781C448.538 105.523 441.592 130.001 453.802 133.49C476.821 140.067 494.265 79.7096 500.383 65.605C504.551 55.995 508.605 46.4774 512.304 36.685C512.716 35.5962 516.057 22.1667 516.057 28.9582C516.057 44.4099 509.439 59.7296 507.558 74.9875C505.278 93.4783 508.331 111.039 508.331 129.406C508.331 131.411 504.758 139.338 508.331 139.561C511.532 139.761 523.127 127.26 525.219 125.322C536.424 114.937 544.824 100.624 551.821 87.1295C552.454 85.9089 556.334 72.9109 554.47 74.4356C545.06 82.1349 516.098 135.211 541.335 138.016C560.178 140.109 585.322 71.4242 565.95 60.5275C565.022 60.0057 572.807 65.1918 575.884 66.0466C587.036 69.1442 596.562 59.0859 603.259 51.4761C611.541 42.0642 611.016 36.7656 625.115 36.2434C645.623 35.4839 619.122 75.2913 616.726 80.9481C614.034 87.3009 600.99 145.488 623.569 139.119C639.837 134.531 653.519 113.221 665.735 102.362C670.789 97.87 677.473 95.4621 681.189 89.889" stroke="black" stroke-width="3" stroke-linecap="round"/>
        <path d="M339.446 56.1122C316.064 57.167 290.642 51.5676 267.919 56.1122" stroke="black" stroke-width="3" stroke-linecap="round"/>
        <path d="M474.554 36.2434L530.186 52.1384" stroke="black" stroke-width="3" stroke-linecap="round"/>
    </svg>

        <!-- <h1>Subscription Detector</h1> -->
        <!-- TODO: MAKE ACCESSIBLE -->
        <p>
            Upload your CSV file to analyze transactions. This tool detects potential subscriptions locally (nothing is uploaded to a server) by finding duplicate amounts and matching posting dates.
        </p>

        <div>
            <input type="file" id="csv-upload" accept=".csv" />
            <button id="process-data">Process</button>
        </div>

        <div class="results">
            <h2>Results</h2>
            <pre id="output" class="tabulation"></pre>
        </div>
    </div>

 <script>
// --------------------------------------------------------------------
// 1) Levenshtein-based fuzzy matching
// --------------------------------------------------------------------
function getLevenshteinDistance(a, b) {
    // Simple iterative version of the Levenshtein distance
    // (Feel free to optimize or replace with your own library.)
    if (!a) return b.length;
    if (!b) return a.length;

    const matrix = [];

    // increment along the first column of each row
    for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
    }

    // increment each column in the first row
    for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
    }

    // Fill in the rest of the matrix
    for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1, // substitution
                    matrix[i][j - 1] + 1,     // insertion
                    matrix[i - 1][j] + 1      // deletion
                );
            }
        }
    }

    return matrix[b.length][a.length];
}

function getSimilarityRatio(strA, strB) {
    // If both strings are empty, treat as exact match
    if (!strA && !strB) return 1.0;
    // Compute Levenshtein distance
    const dist = getLevenshteinDistance(strA.toLowerCase(), strB.toLowerCase());
    const maxLen = Math.max(strA.length, strB.length) || 1; // avoid 0
    return 1 - dist / maxLen;  // ratio in [0..1]
}

function fuzzyNameMatch(strA, strB, threshold = 0.2) {
    // Return true if similarity ratio >= threshold
    return getSimilarityRatio(strA, strB) >= threshold;
}

// --------------------------------------------------------------------
// 2) Logic to find or create a name key, using fuzzy matching
// --------------------------------------------------------------------
function findSimilarNameKey(newName, knownShortNames, threshold = 0.2) {
    for (const existingName of knownShortNames) {
        if (fuzzyNameMatch(newName, existingName, threshold)) {
            // If they are considered "similar enough," return existing
            return existingName;
        }
    }
    // No fuzzy match found
    return null;
}

// --------------------------------------------------------------------
// 3) Main CSV processing
// --------------------------------------------------------------------
function processCSV(csvData) {
    const results = Papa.parse(csvData, {
        header: true,
        skipEmptyLines: true
    });

    // Filter for DEBIT transactions only
    const transactions = results.data.filter(row => row["Details"] === "DEBIT");

    // Dictionary: group by (amount + mergedName)
    const nameAmountGroups = {};

    // Keep track of canonical short names
    const knownShortNames = new Set();

    transactions.forEach(transaction => {
        // 1) Parse the amount
        const amount = parseFloat(transaction["Amount"]);

        // 2) Remove trailing "MM/DD" from the description if it exists
        const descDateRegex = /(\d{1,2}\/\d{1,2})(?!.*\d{1,2}\/\d{1,2})$/;
        const rawDescription = transaction["Description"] || "";
        const proposedShortName = rawDescription.replace(descDateRegex, "").trim();

        // 3) Try to find if there's a known shortName with high similarity
        let mergedShortName = findSimilarNameKey(proposedShortName, knownShortNames, 0.4);

        // 4) If none found, add it to known short names
        if (!mergedShortName) {
            mergedShortName = proposedShortName;
            knownShortNames.add(mergedShortName);
        }

        // 5) Build a unique group key => "amount__mergedShortName"
        const groupKey = `${amount}__${mergedShortName}`;

        // 6) Initialize group if not present
        if (!nameAmountGroups[groupKey]) {
            nameAmountGroups[groupKey] = {
                amount,
                name: mergedShortName,  // the canonical name
                transactions: []
            };
        }

        // 7) Push this transaction into its group
        nameAmountGroups[groupKey].transactions.push(transaction);
    });

    // 8) Identify matches (Potential vs. Strong)
    const potentialMatches = [];
    const strongMatches = [];

    for (const key in nameAmountGroups) {
        const groupObj = nameAmountGroups[key];
        
        // Only consider groups with >1 transaction
        if (groupObj.transactions.length > 1) {
            // Check if day of month (Posting Date) all match
            const postingDays = groupObj.transactions.map(
              item => new Date(item["Posting Date"]).getDate()
            );
            const allDaysSame = postingDays.every(day => day === postingDays[0]);

            if (allDaysSame) {
                strongMatches.push(groupObj);
            } else {
                potentialMatches.push(groupObj);
            }
        }
    }

    return { potentialMatches, strongMatches };
}

// --------------------------------------------------------------------
// 4) Format & display the matches
// --------------------------------------------------------------------
function formatResults(matches, type) {
    let resultText = `${type}:\n\n`;

    matches.forEach(match => {
        // Each match is { amount, name, transactions: [...] }
        resultText += `Amount: $${match.amount}\n`;

        // We'll keep track of the last date we parsed from the Description
        let lastParsedDate = null;
        let lastDayOfMonth = null;

        // Sort by posting date if you'd like:
        // match.transactions.sort((a, b) => new Date(a["Posting Date"]) - new Date(b["Posting Date"]));

        // Iterate over transactions in this group
        match.transactions.forEach((transaction, index) => {
            // The last part of the description might contain "MM/DD"
            const descDateRegex = /(\d{1,2}\/\d{1,2})(?!.*\d{1,2}\/\d{1,2})$/;
            const rawDescription = transaction["Description"] || "";
            const descMatch = rawDescription.match(descDateRegex);

            // Prepare to compute date differences
            const postingDate = new Date(transaction["Posting Date"]);
            const year = postingDate.getFullYear();
            let daysSinceText = "";
            let sameDayText = "";

            if (descMatch) {
                const [mm, dd] = descMatch[1].split('/');
                const parsedDate = new Date(year, parseInt(mm) - 1, parseInt(dd));

                // If we have a lastParsedDate, compute difference
                if (lastParsedDate) {
                    const diffInMs = parsedDate - lastParsedDate;
                    const diffInDays = Math.round(diffInMs / (1000 * 60 * 60 * 24));
                    if (!isNaN(diffInDays)) {
                        // Using +/- for day differences
                        daysSinceText = `(${diffInDays >= 0 ? "+" : ""}${diffInDays} days)`;
                    }

                    // Check same-day-of-month match
                    if (parsedDate.getDate() === lastDayOfMonth) {
                        sameDayText = "(same day match)";
                    }
                }

                // Update references for next iteration
                lastParsedDate = parsedDate;
                lastDayOfMonth = parsedDate.getDate();
            }

            // Build appended text
            let appendedInfo = [daysSinceText, sameDayText].filter(Boolean).join(" ");
            appendedInfo = appendedInfo ? " " + appendedInfo : "";

            // Output lines
            resultText += ` - Description: ${rawDescription}${appendedInfo}\n`;
            resultText += `   Posting Date: ${transaction["Posting Date"]}\n`;
        });

        resultText += "\n";
    });

    return resultText;
}

// --------------------------------------------------------------------
// 5) Hook up the button to process CSV
// --------------------------------------------------------------------
document.getElementById("process-data").addEventListener("click", () => {
    const fileInput = document.getElementById("csv-upload");
    const output = document.getElementById("output");

    if (fileInput.files.length === 0) {
        alert("Please upload a CSV file first.");
        return;
    }

    const file = fileInput.files[0];
    const reader = new FileReader();

    reader.onload = function (event) {
        const csvData = event.target.result;
        const { potentialMatches, strongMatches } = processCSV(csvData);

        // Format and display results
        let resultText = '';
        resultText += formatResults(potentialMatches, "Potential Matches");
        resultText += formatResults(strongMatches, "Strong Matches");

        output.textContent = resultText || "No matches found.";
    };

    reader.readAsText(file);
});
</script>

<!-- Canvas, Vivus, etc. can remain unchanged. -->
<script>
  const canvas = document.getElementById('sketch');
  const rough = rough.canvas(canvas);
  rough.text('Hello!', 50, 100, { fontSize: 24, roughness: 2.5 });
</script>
<script>
function startAnimation() {
    new Vivus('headline-svg', {
        type: 'oneByOne',
        duration: 200,
        start: 'manual'
    }).play();
}
startAnimation();
document.getElementById('headline-svg').addEventListener('click', startAnimation);
</script>
</body>
</html>

<!-- fraud alert -->
<!-- be able to type !!! or ??? when logging -->
<!-- price / with tax / calc tax -->
<!-- tax mode -->
<!-- spouse/partner -->
<!-- link to unsubscribe -->
<!-- rationale: need / work tool / indulgence -->
<!-- help get things expensed by work -->
<!-- track increases -->
<!-- categories -->
<!-- fix today line in chart -->
<!-- reorder spreadsheet by cost/name/active/date -->
<!-- chart doesn't display name -->
<!-- hover on chart should highlight spreadsheet -->
<!-- prioritize name/amount/date matches -->
<!-- find name & amount matches -->
<!-- cross reference to other name matches -->
<!-- find exact date matches / find close date matches / discern billing type -->
<!-- "alert" and "investigate" field -->
<!-- monthly budget -->
<!-- coming soon -->
<!-- custom tags like "cancel when have a job" -->
<!-- shared with other via firebase -->
<!-- came from which account/card -->